//  Copyright (c) 2015-2015 The KID Authors. All rights reserved.
//  Created on: 2015年9月23日 Author: kerry
#include "crawler_task/task_schduler_engine.h"
#include <string>
#include "logic/logic_comm.h"
#include "logic/logic_unit.h"
#include "basic/template.h"
#include "basic/radom_in.h"

namespace crawler_task_logic {

void PrintTaskInfoMap(TASKINFO_MAP& task_info_map)
{
	LOG_MSG2("task_info_map size is %d", task_info_map.size());
	for(TASKINFO_MAP::iterator it = task_info_map.begin(); it != task_info_map.end(); it++)
	{
		base_logic::TaskInfo& task_info = it->second;
		LOG_MSG2("taskid=%ld,id=%ld,crawl_num=%ld,depth=%d,cur_depth=%d,machine=%d,storage=%d",
				it->first,task_info.id(),task_info.crawl_num(),task_info.depth(),task_info.cur_depth(),
				task_info.machine(),task_info.storage());
		LOG_MSG2("method=%d,state=%d,is_login=%d,is_finish=%d,is_forge=%d,is_over=%d,type=%d,",
				task_info.method(),task_info.state(),task_info.is_login(),task_info.is_finish(),
				task_info.is_forge(),task_info.is_over(),task_info.type());
		LOG_MSG2("create_time=%ld,polling_time=%ld,base_polling_time=%ld,last_task_time=%ld,attrid=%ld,url=%s",
				task_info.create_time(),task_info.polling_time(),task_info.base_polling_time(),task_info.last_task_time(),
				task_info.attrid(),task_info.url().c_str());
	}
}

TaskSchdulerManager* TaskSchdulerEngine::schduler_mgr_ = NULL;
TaskSchdulerEngine* TaskSchdulerEngine::schduler_engine_ = NULL;

TaskSchdulerManager::TaskSchdulerManager()
:crawler_count_(0)
,task_db_(NULL){
    task_cache_ = new TaskSchdulerCache();
    Init();
}

TaskSchdulerManager::~TaskSchdulerManager() {
    DeinitThreadrw(lock_);
}

void TaskSchdulerManager::Init() {
    InitThreadrw(&lock_);
}

void TaskSchdulerManager::InitDB(crawler_task_logic::CrawlerTaskDB* task_db) {
    task_db_ = task_db;
}

void TaskSchdulerManager::Init(crawler_schduler::SchdulerEngine* crawler_engine) {
    crawler_schduler_engine_ = crawler_engine;
}


void TaskSchdulerManager::FetchBatchTask(
        std::list<base_logic::TaskInfo>* list,
        bool is_first) {
    base_logic::WLockGd lk(lock_);
    time_t current_time = time(NULL);
    while ((*list).size() > 0) {
        base_logic::TaskInfo info = (*list).front();
        (*list).pop_front();
        // 更新时间
        info.update_time(current_time,
                base::SysRadom::GetInstance()->GetRandomID(),
                is_first);
        task_cache_->task_idle_map_[info.id()] = info;
    }
    LOG_MSG2("task_cache_->task_idle_map_ size is %ld", task_cache_->task_idle_map_.size());
    PrintTaskInfoMap(task_cache_->task_idle_map_);
}

void TaskSchdulerManager::FetchBatchTemp(
        std::list<base_logic::TaskInfo>* list) {
    base_logic::WLockGd lk(lock_);
    while((*list).size() > 0) {
        base_logic::TaskInfo info = (*list).front();
        (*list).pop_front();
        task_cache_->task_temp_list_.push_back(info);
    }
    LOG_MSG2("fetchbatchtemp task_temp_list_ size %d", task_cache_->task_temp_list_.size());
}

bool TaskSchdulerManager::AlterTaskState(const int64 task_id,
        const int8 state) {
    base_logic::WLockGd lk(lock_);
    base_logic::TaskInfo task;
    bool r = base::MapGet<TASKINFO_MAP, TASKINFO_MAP::iterator,
            int64, base_logic::TaskInfo>(task_cache_->task_exec_map_,
                    task_id, task);
    if (r) {
        if (state == TASK_EXECUED) {
            base::MapDel<TASKINFO_MAP, TASKINFO_MAP::iterator, int64>
            (task_cache_->task_exec_map_, task_id);
        }
        LOG_MSG2("set task state %d,task_id = %ld", state, task_id);
        task.set_state(state);
    }
    return r;
}

bool TaskSchdulerManager::AlterCrawlNum(const int64 task_id, const int64 num) {
    base_logic::WLockGd lk(lock_);
    base_logic::TaskInfo task;
    bool r = base::MapGet<TASKINFO_MAP, TASKINFO_MAP::iterator,
            int64, base_logic::TaskInfo>(task_cache_->task_exec_map_,
                    task_id, task);
    if (r)
        task.set_crawl_num(num);
    return r;
}



void TaskSchdulerManager::RecyclingTask() {
    PrintTaskInfo();
    base_logic::WLockGd lk(lock_);
    TASKINFO_MAP::iterator it =
            task_cache_->task_exec_map_.begin();
    time_t current_time = time(NULL);
    LOG_MSG2("before recycling task_exec_map_ size %d,current_time=%ld",task_cache_->task_exec_map_.size(),current_time);
    for (; it != task_cache_->task_exec_map_.end();) {
        base_logic::TaskInfo task = it->second;
        task_db_->RecordTaskState(task,2);
        // 检测当前时间大于 polling time 1.5倍  则回收
        if((task.last_task_time() + 300)
              <  current_time) {
            task.set_state(TASK_WAIT);
            task_cache_->task_exec_map_.erase(it++);
            // 临时任务则放回临时list
            if (task.type() == TEMP_LASTING_TASK ||
                    task.type() == TEMP_SHORT_TASK) {
                task.update_time();
                task_cache_->task_temp_list_.push_back(task);
            }
        } else {
            it++;
        }
    }
    LOG_MSG2("after recycling task_exec_map_ size %d",task_cache_->task_exec_map_.size());
    LOG_MSG2("task_temp_list_ size %d", task_cache_->task_temp_list_.size());
    PrintTaskInfo();
}

bool TaskSchdulerManager::DistributionTempTask() {

    LOG_MSG2("crawler_task task_temp_list_ size  %d", task_cache_->task_temp_list_.size());
    LOG_MSG2("crawler_task task_exec_map_ size  %d", task_cache_->task_exec_map_.size());
    for(std::list<base_logic::TaskInfo>::iterator it = task_cache_->task_temp_list_.begin(); it != task_cache_->task_temp_list_.end(); it++) {
        	base_logic::TaskInfo& task_info = *it;
        	LOG_MSG2("id=%ld,crawl_num=%ld,depth=%d,cur_depth=%d,machine=%d,storage=%d",
        			task_info.id(),task_info.crawl_num(),task_info.depth(),task_info.cur_depth(),
        			task_info.machine(),task_info.storage());
    		LOG_MSG2("method=%d,state=%d,is_login=%d,is_finish=%d,is_forge=%d,is_over=%d,type=%d,",
    				task_info.method(),task_info.state(),task_info.is_login(),task_info.is_finish(),
    				task_info.is_forge(),task_info.is_over(),task_info.type());
    		LOG_MSG2("create_time=%ld,polling_time=%ld,base_polling_time=%ld,last_task_time=%ld,attrid=%ld,url=%s",
    				task_info.create_time(),task_info.polling_time(),task_info.base_polling_time(),task_info.last_task_time(),
    				task_info.attrid(),task_info.url().c_str());
        }
    if (task_cache_->task_temp_list_.size() <= 0)
        return true;
    if (!crawler_schduler_engine_->CheckOptimalCrawler()) {
         LOG_MSG("no have OptimalCrawler");
         return true;
     }
    int32 base_num = 5;
    struct AssignmentMultiTask  task;
    MAKE_HEAD(task, ASSIGNMENT_MULTI_TASK, 0, 0, 0, 0);
    base_logic::WLockGd lk(lock_);

    while(task_cache_->task_temp_list_.size() > 0) {

        base_logic::TaskInfo info = task_cache_->task_temp_list_.front();
        task_cache_->task_temp_list_.pop_front();
        task_db_->RecordTaskState(info,1);
        if ((info.state() == TASK_WAIT || info.state() == TASK_EXECUED)) {
            struct TaskUnit* unit = new struct TaskUnit;
            unit->task_id = info.id();
            unit->attr_id = info.attrid();
            unit->max_depth = info.depth();
            unit->current_depth = info.cur_depth();
            unit->machine = info.machine();
            unit->storage = info.storage();
            unit->is_login = info.is_login();
            unit->is_over = info.is_over();
            unit->is_forge = info.is_forge();
            unit->method = info.method();
            memset(unit->url, '\0', URL_SIZE);
            memcpy(unit->url, info.url().c_str(),
                    (URL_SIZE - 1) < info.url().length() ?
                    (URL_SIZE - 1) : info.url().length());
            task.task_set.push_back(unit);
            info.set_state(TASK_SEND);
            task_cache_->task_exec_map_[info.id()] = info;
            if (task.task_set.size() % base_num == 0 &&
                    task.task_set.size() != 0) {
                crawler_schduler_engine_->SendOptimalCrawler((const void*)&task, 0);
                net::PacketProsess::ClearCrawlerTaskList(&task);
            }
        }
    }

    //解决余数
    if (task.task_set.size() > 0) {
        crawler_schduler_engine_->SendOptimalCrawler((const void*)&task, 0);
        net::PacketProsess::ClearCrawlerTaskList(&task);
    }

    LOG_MSG2("task_temp_list_ size %d", task_cache_->task_temp_list_.size());
    return true;
}


bool TaskSchdulerManager::DistributionTask() {
    LOG_MSG2("DistributionTask crawler_task task_idle_list_ size  %d", task_cache_->task_idle_map_.size());
    LOG_MSG2("DistributionTask crawler_task task_exec_map_ size  %d", task_cache_->task_exec_map_.size());
    PrintTaskInfo();
    int32 base_num = 5;
    if (task_cache_->task_idle_map_.size() <= 0)
        return true;
   if (!crawler_schduler_engine_->CheckOptimalCrawler()) {
        LOG_MSG("no have OptimalCrawler");
        return true;
    }

    time_t current_time = time(NULL);

    struct AssignmentMultiTask  task;
    MAKE_HEAD(task, ASSIGNMENT_MULTI_TASK, 0, 0, 0, 0);
    base_logic::WLockGd lk(lock_);

    int32 count = task_cache_->task_idle_map_.size();
    int32 mutil = count / base_num;
    int32 residue = count % base_num;
    int32 index = 0;


    TASKINFO_MAP::iterator it = task_cache_->task_idle_map_.begin();

    for(;it != task_cache_->task_idle_map_.end(),index < count;it++,index++) {
        base_logic::TaskInfo info = it->second;
        task_db_->RecordTaskState(info,0);
        LOG_MSG2("id %lld current %lld last_time %lld polling_time %lld state %d",
                info.id(), current_time, info.last_task_time(),
                info.polling_time(), info.state());
       /*info.update_time(current_time, base::SysRadom::GetInstance()->GetRandomID());*/
        if ((info.state() == TASK_WAIT || info.state() == TASK_EXECUED)
                        /*&& (current_time >  info.last_task_time() +
                                      info.polling_time())*/) {
	    LOG_MSG2("task_id=%d", info.id());
            struct TaskUnit* unit = new struct TaskUnit;
            unit->task_id = info.id();
            unit->attr_id = info.attrid();
            unit->max_depth = info.depth();
            unit->current_depth = info.cur_depth();
            unit->machine = info.machine();
            unit->storage = info.storage();
            unit->is_login = info.is_login();
            unit->is_over = info.is_over();
            unit->is_forge = info.is_forge();
            unit->method = info.method();
            memset(unit->url, '\0', URL_SIZE);
            memcpy(unit->url, info.url().c_str(),
                    (URL_SIZE - 1) < info.url().length() ?
                    (URL_SIZE - 1) : info.url().length());
            task.task_set.push_back(unit);
            info.set_state(TASK_SEND);
            info.update_time(current_time, base::SysRadom::GetInstance()->GetRandomID());
            task_cache_->task_exec_map_[info.id()] = info;
            if (task.task_set.size() % base_num == 0 &&
                    task.task_set.size() != 0) {
		//LOG_MSG2("send optimal crawler");
                crawler_schduler_engine_->SendOptimalCrawler((const void*)&task, 0);
		//LOG_MSG2("");
                net::PacketProsess::ClearCrawlerTaskList(&task);
            }
        }
    }

    //解决余数
    if (task.task_set.size() > 0) {
        crawler_schduler_engine_->SendOptimalCrawler((const void*)&task, 0);
        net::PacketProsess::ClearCrawlerTaskList(&task);
    }
    PrintTaskInfo();
    return true;
}

void TaskSchdulerManager::CheckIsEffective() {
    crawler_schduler_engine_->CheckIsEffective();
}

void TaskSchdulerManager::PrintTaskInfo()
{
	LOG_MSG2("task_cache_->task_temp_list_ size is %ld", task_cache_->task_temp_list_.size());
    LOG_MSG2("task_cache_->task_idle_map_ size is %ld", task_cache_->task_idle_map_.size());
    PrintTaskInfoMap(task_cache_->task_idle_map_);
    LOG_MSG2("task_cache_->task_exec_map_ size is %ld", task_cache_->task_exec_map_.size());
    PrintTaskInfoMap(task_cache_->task_exec_map_);
}

}  // namespace task_logic
